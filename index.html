<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Blocks Language Playground</title>
  <link rel="stylesheet" href="/playground.css">
  <script src="https://unpkg.com/@alenaksu/json-viewer@2.1.0/dist/json-viewer.bundle.js"></script>
</head>
<body>
  <div class="playground-container">
    <!-- Header -->
    <div class="playground-header">
      <h1>üß± Blocks Language Playground</h1>
      <p>Interactive parser and AST visualizer</p>
    </div>

    <!-- Error Banner -->
    <div class="error-banner" id="errorBanner">
      <strong>‚ö†Ô∏è Parse Errors:</strong>
      <ul class="error-list" id="errorList"></ul>
    </div>

    <!-- Examples -->
    <div class="examples-bar">
      <button class="btn" data-example="basics">Basics</button>
      <button class="btn" data-example="scripts">Scripts</button>
      <button class="btn" data-example="attributes">Attributes</button>
      <button class="btn" data-example="inlines">Inlines</button>
      <button class="btn" data-example="nested">Nested</button>
      <button class="btn" data-example="codeblock">Code Block</button>
      <button class="btn" data-example="comments">Comments</button>
      <button class="btn" data-example="invoice">Invoice</button>
      <button class="btn btn-primary" id="processBtn">‚ö° Process</button>
    </div>

    <!-- Layout -->
    <div class="playground-layout">
      <!-- Left: Source Input -->
      <div class="playground-left">
        <div class="panel-header">Source</div>
        <textarea 
          class="source-editor" 
          id="sourceInput" 
          placeholder="Type or paste Blocks code here..."
          spellcheck="false"
        ></textarea>
      </div>

      <!-- Middle: Variables Panel -->
      <div class="playground-middle">
        <div class="panel-header">Variables (JSON)</div>
        <textarea 
          class="variables-editor" 
          id="variablesInput" 
          placeholder='{\n  "key": "value"\n}'
          spellcheck="false"
        >{}</textarea>
      </div>

      <!-- Right: Output Tabs -->
      <div class="playground-right">
        <!-- Tabs -->
        <div class="tabs">
          <button class="tab active" data-tab="output">üìÑ Output</button>
          <button class="tab" data-tab="tokens">üî§ Tokens</button>
          <button class="tab" data-tab="astTree">üå≥ AST Tree</button>
          <button class="tab" data-tab="astJson">üìä AST JSON</button>
        </div>

        <!-- Output Tab -->
        <div class="tab-content active" id="outputTab">
          <pre class="output-display" id="outputDisplay"></pre>
        </div>

        <!-- Tokens Tab -->
        <div class="tab-content" id="tokensTab">
          <div class="tokens-list" id="tokensList"></div>
        </div>

        <!-- AST Tree Tab -->
        <div class="tab-content" id="astTreeTab">
          <div class="ast-tree" id="astTree"></div>
        </div>

        <!-- AST JSON Tab -->
        <div class="tab-content json-container" id="astJsonTab">
          <json-viewer id="astJson"></json-viewer>
        </div>

        <!-- Actions -->
        <div class="actions-bar">
          <button class="btn" id="copyJsonBtn">üìã Copy JSON</button>
          <button class="btn" id="clearBtn">üóëÔ∏è Clear</button>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import { parse, evaluate, render } from './src/index.ts';
    import { createLexer } from './src/lexer/lexer.ts';

    // Examples - All Spec v1.0 compliant
    const examples = {
      basics: {
        name: "Basics",
        source: `:::section {#intro .welcome}
Welcome to Blocks!

Result: \${2 + 2}
:::`,
        variables: { }
      },
      scripts: {
        name: "Scripts",
        source: `Total: \${price * quantity}
Tax: \${total * 0.1}
Grand Total: \${total * 1.1}`,
        variables: { price: 10, quantity: 5, total: 50 }
      },
      attributes: {
        name: "Attributes",
        source: `:::div {#main .container .flex lang=en theme=dark}
Block with attributes
:::

Text with \`code\`{#c1 .highlight} inline.`,
        variables: { }
      },
      inlines: {
        name: "Inlines",
        source: `Text with \`inline code\` and code\`content\` formats.

:::section
More text with \`js console.log()\` examples.
:::`,
        variables: { }
      },
      nested: {
        name: "Nested",
        source: `:::outer {.container}
Value: \${x}

::::inner {.box}
Double: \${x * 2}
::::
:::`,
        variables: { x: 5 }
      },
      codeblock: {
        name: "Code Block",
        source: `\`\`\`javascript
function hello() {
  console.log("Hello, world!");
}
\`\`\``,
        variables: { }
      },
      comments: {
        name: "Comments",
        source: `/* This is a block comment */
:::section
content with \${value}
:::
/* Another comment */`,
        variables: { value: 42 }
      },
      invoice: {
        name: "Invoice",
        source: `:::invoice {#inv-001 .document}
Customer: \${customer.name}
Email: \${customer.email}

Items:
- Product A: $\${items.productA}
- Product B: $\${items.productB}

Subtotal: $\${items.productA + items.productB}
Tax (10%): $\${(items.productA + items.productB) * 0.1}
Total: $\${(items.productA + items.productB) * 1.1}
:::`,
        variables: {
          customer: { name: "Alice Smith", email: "alice@example.com" },
          items: { productA: 100, productB: 200 }
        }
      }
    };

    // State
    let currentTokens = [];
    let currentAST = null;
    let currentOutput = '';
    let nodeIdCounter = 0;

    // Elements
    const sourceInput = document.getElementById('sourceInput');
    const variablesInput = document.getElementById('variablesInput');
    const outputDisplay = document.getElementById('outputDisplay');
    const errorBanner = document.getElementById('errorBanner');
    const errorList = document.getElementById('errorList');
    const tokensList = document.getElementById('tokensList');
    const astTree = document.getElementById('astTree');
    const astJson = document.getElementById('astJson');
    const processBtn = document.getElementById('processBtn');
    const copyJsonBtn = document.getElementById('copyJsonBtn');
    const clearBtn = document.getElementById('clearBtn');

    // Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        const targetTab = tab.dataset.tab;
        
        // Update active tab
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        // Update active content
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        document.getElementById(`${targetTab}Tab`).classList.add('active');
      });
    });

    // Example buttons
    document.querySelectorAll('[data-example]').forEach(btn => {
      btn.addEventListener('click', () => {
        const exampleKey = btn.dataset.example;
        const example = examples[exampleKey];
        sourceInput.value = example.source;
        variablesInput.value = JSON.stringify(example.variables, null, 2);
        processSource();
      });
    });

    // Process button
    processBtn.addEventListener('click', () => {
      processSource();
    });

    // Auto-process on input (debounced)
    let processTimeout;
    sourceInput.addEventListener('input', () => {
      clearTimeout(processTimeout);
      processTimeout = setTimeout(processSource, 500);
    });

    variablesInput.addEventListener('input', () => {
      clearTimeout(processTimeout);
      processTimeout = setTimeout(processSource, 500);
    });

    // Copy JSON
    copyJsonBtn.addEventListener('click', () => {
      if (currentAST) {
        navigator.clipboard.writeText(JSON.stringify(currentAST, null, 2));
        copyJsonBtn.textContent = '‚úÖ Copied!';
        setTimeout(() => {
          copyJsonBtn.textContent = 'üìã Copy JSON';
        }, 2000);
      }
    });

    // Clear
    clearBtn.addEventListener('click', () => {
      sourceInput.value = '';
      variablesInput.value = '{}';
      currentTokens = [];
      currentAST = null;
      currentOutput = '';
      outputDisplay.textContent = '';
      tokensList.innerHTML = '<p class="empty-state">No tokens yet. Type some code!</p>';
      astTree.innerHTML = '<p class="empty-state">No AST yet. Type some code!</p>';
      astJson.data = null;
      errorBanner.classList.remove('visible');
    });

    // Process source: Parse ‚Üí Evaluate ‚Üí Render
    function processSource() {
      const source = sourceInput.value;

      if (!source.trim()) {
        clearBtn.click();
        return;
      }

      try {
        // Parse variables
        let variables = {};
        try {
          const varsText = variablesInput.value.trim();
          if (varsText) {
            variables = JSON.parse(varsText);
          }
        } catch (e) {
          errorList.innerHTML = `<li>Invalid JSON in variables: ${e.message}</li>`;
          errorBanner.classList.add('visible');
          return;
        }

        // Tokenize
        const lexer = createLexer();
        const { tokens } = lexer.tokenize(source);
        currentTokens = tokens;

        // Parse
        const result = parse(source);
        
        // Display errors
        if (result.errors.length > 0) {
          errorList.innerHTML = result.errors.map(e => `<li>${e}</li>`).join('');
          errorBanner.classList.add('visible');
        } else {
          errorBanner.classList.remove('visible');
        }

        // Evaluate with context
        const evaluated = evaluate(result.ast, { variables });
        currentAST = evaluated;

        // Render output
        currentOutput = render(evaluated);

        // Display views
        renderOutput(currentOutput);
        renderTokens(tokens);
        renderASTTree(evaluated);
        renderASTJSON(evaluated);

      } catch (error) {
        errorList.innerHTML = `<li>${error.message}</li>`;
        errorBanner.classList.add('visible');
      }
    }

    // Render output
    function renderOutput(output) {
      outputDisplay.textContent = output || '(empty)';
    }

    // Render tokens
    function renderTokens(tokens) {
      if (tokens.length === 0) {
        tokensList.innerHTML = '<p class="empty-state">No tokens</p>';
        return;
      }

      tokensList.innerHTML = tokens
        .map((token, idx) => {
          const type = token.tokenType.name;
          const value = token.image.replace(/\n/g, '\\n').replace(/\t/g, '\\t');
          const loc = `L${token.startLine}:${token.startColumn}`;
          
          return `
            <div class="token-item">
              <span class="token-type">${type}</span>
              <span class="token-value">${escapeHtml(value)}</span>
              <span class="token-location">${loc}</span>
            </div>
          `;
        })
        .join('');
    }

    // Render AST Tree
    function renderASTTree(ast) {
      nodeIdCounter = 0; // Reset counter for each render
      astTree.innerHTML = renderASTNode(ast, 0);
      
      // Add event delegation for toggle functionality
      astTree.addEventListener('click', (e) => {
        const header = e.target.closest('.ast-node-header');
        if (header) {
          const nodeId = header.dataset.nodeId;
          const childrenContainer = header.nextElementSibling;
          if (childrenContainer && childrenContainer.classList.contains('ast-node-children')) {
            childrenContainer.classList.toggle('collapsed');
            const toggle = header.querySelector('.ast-toggle');
            if (toggle) {
              toggle.textContent = childrenContainer.classList.contains('collapsed') ? '‚ñ∂' : '‚ñº';
            }
          }
        }
      });
    }

    function renderASTNode(node, depth) {
      if (!node) return '';

      const type = node.type || 'Unknown';
      let info = '';
      let children = [];

      // Extract node info
      if (node.type === 'GenericBlock') {
        info = `name="${node.name}"`;
        children = node.content || [];
      } else if (node.type === 'CodeBlock') {
        info = node.language ? `lang="${node.language}"` : '';
        children = node.content || [];
      } else if (node.type === 'GenericInline') {
        info = `name="${node.name}"`;
        children = node.content || [];
      } else if (node.type === 'Text') {
        const preview = node.value.substring(0, 50);
        info = `"${preview}${node.value.length > 50 ? '...' : ''}"`;
      } else if (node.type === 'Document') {
        children = node.children || [];
      } else if (node.content) {
        children = Array.isArray(node.content) ? node.content : [];
      }

      // Render attributes
      if (node.attributes) {
        const attrs = [];
        if (node.attributes.id) attrs.push(`#${node.attributes.id}`);
        if (node.attributes.classes?.length) attrs.push(`.${node.attributes.classes.join('.')}`);
        if (attrs.length) info += ` {${attrs.join(' ')}}`;
      }

      const hasChildren = children.length > 0;
      const nodeId = `node-${nodeIdCounter++}`;

      let html = `
        <div class="ast-node">
          <div class="ast-node-header" data-node-id="${nodeId}">
            <span class="ast-toggle">${hasChildren ? '‚ñº' : '  '}</span>
            <span class="ast-node-type">${type}</span>
            ${info ? `<span class="ast-node-info">${escapeHtml(info)}</span>` : ''}
          </div>
      `;

      if (hasChildren) {
        html += `<div class="ast-node-children" id="${nodeId}">`;
        children.forEach(child => {
          html += renderASTNode(child, depth + 1);
        });
        html += '</div>';
      }

      html += '</div>';
      return html;
    }

    // Render AST JSON
    function renderASTJSON(ast) {
      astJson.data = ast;
    }

    // Escape HTML
    function escapeHtml(str) {
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }

    // Initial load
    const firstExample = examples.basics;
    sourceInput.value = firstExample.source;
    variablesInput.value = JSON.stringify(firstExample.variables, null, 2);
    processSource();
  </script>
</body>
</html>

<!--
/* This is a comment block */
/* #include header.html */
/* #config { #settings .important %readonly } some content */

// Simple comment
//#todo Fix later
`console.log()`
`#js alert()`{.hl}
!getValue()!
!#py script!{#s1}
:#name content:{.k}
:content:
::
:text with `code`:


!!!
<p> content </p>
!!!

!!!#html {#id .class1 .class2 %opt1 %opt2}
<p> HTML content </p>
!!!

:::#container
text with `code` and :emphasis:
:::

:::#container {#id .class1 .class2 %opt1 %opt2}
text with `code` and :emphasis:
:::

un petit texte avec `du code`{#id} et de :lemphase: et du vide :: 


:::#container
text with `code`{#id} and :emphasis:
et du HTML
<p> content </p>
:::

```
<dfn></dfn>
```

:::
bloc externe

::::: #id
bloc interne (5 deux-points)
:::::

:::

// Avec noms
:::#outer
  :::::#inner
  contenu
  :::::
:::

// Avec attributs
:::{.wrapper}
  :::::{.content}
  text
  :::::
:::

// Avec contenu mixte
:::#container
text `code`
:::::
<p>HTML</p>
:::::
:::
-->